#!/usr/bin/env python3
"""
ğŸš€ KissBotV3 WORKING - TwitchIO 3.x Based on REAL Examples
BasÃ© sur les exemples officiels GitHub PythonistaGuild/TwitchIO
"""

import asyncio
import logging
import time
from typing import Any

import yaml
import twitchio
from twitchio import eventsub
from twitchio.ext import commands

# Setup logging comme dans les exemples
LOGGER = logging.getLogger(__name__)


def load_config():
    """Load configuration from YAML file."""
    with open('config/config.yaml', 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)


class KissBotV3Working(commands.Bot):
    """ğŸ¯ TwitchIO 3.x Bot QUI MARCHE - BasÃ© sur les vrais exemples !"""

    def __init__(self, **kwargs: Any) -> None:
        config = load_config()
        twitch_config = config.get("twitch", {})
        
        # RÃ©cupÃ©rer les channels pour IRC
        channels = twitch_config.get("channels", [])
        
        # RÃ©cupÃ©rer le token du bot pour IRC
        bot_token = None
        tokens = twitch_config.get("tokens", {})
        for account_name, token_info in tokens.items():
            if str(token_info.get("user_id")) == str(twitch_config.get("bot_id")):
                bot_token = token_info.get("access_token")
                LOGGER.info(f"ğŸ”‘ Token IRC trouvÃ© pour {account_name}")
                break

        # TwitchIO 3.x: EventSub WebSocket + IRC Fallback
        # ğŸ¯ STRATÃ‰GIE:
        #   - Primary: EventSub WebSocket (moderne, powerful)
        #   - Fallback: IRC (pragmatique, fiable, marche mÃªme sans bons scopes)
        # ğŸ“¡ Les deux tournent en parallÃ¨le - meilleur des 2 mondes !

        super().__init__(
            token=bot_token,  # ğŸ”‘ TOKEN IRC pour envoyer des messages
            client_id=twitch_config.get("client_id", ""),
            client_secret=twitch_config.get("client_secret", ""),
            bot_id=twitch_config.get("bot_id", ""),
            owner_id=twitch_config.get("bot_id", ""),  # MÃªme compte = autorisation totale
            prefix=twitch_config.get("prefix", "!"),
            initial_channels=channels,  # ğŸ”Œ Activer IRC en parallÃ¨le d'EventSub
        )

        self.config = config
        
        # ğŸ” Store client_id for scope validation
        self.client_id = twitch_config.get("client_id", "")
        
        # ğŸ”Œ IRC Bridge (asyncio pur) pour fallback universel
        from twitch.irc_bridge import TwitchIRCBridge
        
        # Normaliser le token OAuth pour IRC
        irc_oauth = bot_token if bot_token and bot_token.startswith("oauth:") else f"oauth:{bot_token}" if bot_token else None
        
        self.irc_bridge = TwitchIRCBridge(
            nick=twitch_config.get("bot_login", "serda_bot"),
            oauth=irc_oauth,
            channels=channels,
            max_msgs_per_30s=18  # Safe pour non-verified
        ) if irc_oauth else None
        
        self.irc_channels = channels

        # ğŸ¯ INITIALISER LES DÃ‰PENDANCES KISSBOT
        from backends.game_cache import GameCache

        self.start_time = time.time()
        self.bot_display_name = ""
        self.bot_login_name = ""
        self.game_cache = GameCache(config)  # Passer la config

        LOGGER.info("ğŸ¯ KissBotV3Working crÃ©Ã© avec TwitchIO 3.x + IRC Bridge asyncio")

    async def setup_hook(self) -> None:
        """Setup hook - BASÃ‰ SUR LES EXEMPLES OFFICIELS"""
        LOGGER.info("ğŸ”§ Setup hook - Ajout des components...")

        # ï¿½ CRUCIAL: Charger les User Access Tokens depuis .tio.tokens.json

        # ï¿½ğŸ”‘ CRUCIAL: Charger les User Access Tokens depuis .tio.tokens.json
        # TwitchIO 3.x nÃ©cessite les tokens POUR LES DEUX COMPTES:
        #   1. Bot token (pour recevoir les messages)
        #   2. Broadcaster token (pour les subscriptions EventSub)
        # ğŸ”‘ Charger les tokens depuis config.yaml
        try:
            tokens_config = self.config.get("twitch", {}).get("tokens", {})

            if not tokens_config:
                LOGGER.warning("âš ï¸ Aucun token trouvÃ© dans config.yaml!")
            else:
                for account_name, token_info in tokens_config.items():
                    user_id = token_info.get("user_id")
                    token = token_info.get("access_token", "").replace("oauth:", "")
                    refresh = token_info.get("refresh_token", "")

                    if token:
                        LOGGER.info(f"ğŸ”‘ Ajout du token pour {account_name} ({user_id})...")
                        await self.add_token(token, refresh)
                        LOGGER.info(f"âœ… Token ajoutÃ© pour {account_name}")
                    else:
                        LOGGER.warning(f"âš ï¸ Token vide pour {account_name}")

                LOGGER.info(f"âœ… {len(tokens_config)} tokens chargÃ©s depuis config.yaml")
                
                # ğŸ” VALIDATION DES SCOPES (aprÃ¨s refresh par TwitchIO)
                from core.scope_validator import ScopeValidator
                
                LOGGER.info("ğŸ” Validation des scopes OAuth (post-refresh)...")
                self.disabled_features = []
                self.channels_without_badge = []  # Track channels sans badge vÃ©rifiÃ©
                self.use_irc_mode = False  # Par dÃ©faut EventSub, sauf si pas de channel:bot
                self.user_scopes = {}  # Store scopes par user_id
                
                for account_name, token_info in tokens_config.items():
                    # Use refreshed token from TwitchIO
                    user_id = str(token_info.get("user_id"))
                    
                    # Get token from TwitchIO's managed tokens (already refreshed!)
                    if user_id in self._http._tokens:
                        managed_token = self._http._tokens[user_id]
                        
                        # TwitchIO stores tokens as dict with key 'token'
                        access_token = managed_token.get("token")
                        
                        if not access_token:
                            LOGGER.warning(f"âš ï¸  Impossible d'extraire token pour {account_name}")
                            continue
                        
                        # Validate scopes
                        analysis = await ScopeValidator.validate_token(
                            token=access_token,
                            client_id=self.client_id
                        )
                        
                        # Print detailed report
                        print(f"\nğŸ” Validation OAuth: {account_name}")
                        ScopeValidator.print_scope_report(analysis)
                        
                        # Store scopes par user_id
                        self.user_scopes[user_id] = analysis["scopes"]
                        
                        # Check for verified bot badge (channel:bot scope)
                        has_badge = "channel:bot" in analysis["scopes"]
                        if not has_badge:
                            self.channels_without_badge.append(account_name)
                            self.use_irc_mode = True  # Forcer IRC si au moins 1 channel sans badge
                        
                        # Store disabled features (but don't block startup)
                        if analysis["unavailable_features"]:
                            self.disabled_features.extend(analysis["unavailable_features"])
                            # Don't log here - already shown in scope report
                    else:
                        LOGGER.warning(f"âš ï¸  Token non trouvÃ© dans TwitchIO pour {account_name}")
                
                # Remove duplicates
                self.disabled_features = list(set(self.disabled_features))
                
                # ğŸ–ï¸ DÃ‰CISION: MODE IRC OU EVENTSUB ?
                if self.use_irc_mode:
                    print("\n" + "=" * 60)
                    print("ğŸ”Œ MODE IRC ACTIVÃ‰ (Pas de scope channel:bot)")
                    print("=" * 60)
                    for channel in self.channels_without_badge:
                        print(f"âš ï¸  {channel}: Pas de badge vÃ©rifiÃ©")
                    print("\nğŸ’¡ Le bot fonctionnera en mode IRC classique:")
                    print("   âœ… Toutes les commandes disponibles")
                    print("   âœ… Marche PARTOUT sans mod ni scope")
                    print("   âŒ Pas de badge 'Verified Bot' dans le chat")
                    print("   âš¡ Messages via IRC (pas d'API Helix)")
                    print("\nğŸ“‹ Pour le badge vÃ©rifiÃ©:")
                    print("   RÃ©gÃ©nÃ©rer OAuth avec scope 'channel:bot'")
                    print("=" * 60 + "\n")
                    LOGGER.info("ğŸ”Œ Mode IRC pur activÃ© (pas d'EventSub)")
                else:
                    print("\nâœ… Mode EventSub activÃ© (badge vÃ©rifiÃ© disponible)\n")
                    LOGGER.info("âœ… Mode EventSub activÃ© avec badge vÃ©rifiÃ©")
                
                # ğŸ–ï¸ ANCIEN AVERTISSEMENT (deprecated)
                if False and self.channels_without_badge:
                    print("\n" + "=" * 60)
                    print("âš ï¸  ATTENTION: MODE DEMO (Sans badge vÃ©rifiÃ©)")
                    print("=" * 60)
                    for channel in self.channels_without_badge:
                        print(f"âŒ {channel}: Pas de scope 'channel:bot'")
                    print("\nğŸ’¡ Le bot fonctionnera avec fallback IRC:")
                    print("   âœ… Toutes les commandes disponibles")
                    print("   âŒ Pas de badge 'Verified Bot' dans le chat")
                    print("   âš¡ Utilisera IRC au lieu de l'API Helix")
                    print("\nğŸ“‹ Pour obtenir le badge vÃ©rifiÃ©:")
                    print("   1. Demander au broadcaster: /mod serda_bot")
                    print("   2. OU rÃ©gÃ©nÃ©rer OAuth avec scope 'channel:bot'")
                    print("=" * 60 + "\n")
                
        except Exception as e:
            LOGGER.error(f"âŒ Erreur lors du chargement des tokens: {e}")

        # ğŸ¯ IMPORTER NOS COMMANDES TWITCHIO 3.x !
        from commands.utils_commands import UtilsCommands
        from commands.game_commands import GameCommands
        from commands.intelligence_commands import IntelligenceCommands
        from commands.translation import TranslationCommands
        from commands.quantum_commands import QuantumCommands

        # Ajouter nos components TwitchIO 3.x (passer config pour cooldowns)
        await self.add_component(UtilsCommands())
        await self.add_component(GameCommands())
        await self.add_component(IntelligenceCommands(config=self.config))
        await self.add_component(TranslationCommands(config=self.config))
        await self.add_component(QuantumCommands())
        LOGGER.info("âœ… Commandes KissBot TwitchIO 3.x ajoutÃ©es")
        
        # ğŸ”§ MONKEY-PATCH: Wrapper automatique pour fallback IRC sur 401
        self._setup_irc_fallback()

        # ğŸ” DEBUG : Lister les commandes enregistrÃ©es
        print(f"ğŸ” Commandes enregistrÃ©es: {list(self.commands.keys())}")
        LOGGER.info(f"ğŸ” Total commandes: {len(self.commands)}")

        # ğŸ¯ RÃ‰CUPÃ‰RER LE NOM DU BOT VIA L'API HELIX
        try:
            # Utiliser l'API Helix pour rÃ©cupÃ©rer les infos du bot
            users = await self.fetch_users(ids=[self.bot_id])
            if users:
                self.bot_display_name = users[0].display_name
                bot_name = users[0].name
                self.bot_login_name = (bot_name.lower() if bot_name else "kissbot")
                LOGGER.info(
                    f"ğŸ¤– Bot nom rÃ©cupÃ©rÃ© via API: "
                    f"{self.bot_display_name} ({self.bot_login_name})"
                )
                print(f"ğŸ¤– Bot identifiÃ©: {self.bot_display_name} (@{self.bot_login_name})")
            else:
                # Fallback sur la config
                self.bot_display_name = self.config.get("bot", {}).get("name", "KissBot")
                self.bot_login_name = self.bot_display_name.lower()
                LOGGER.warning(f"âš ï¸ Fallback config bot: {self.bot_display_name}")
        except Exception as e:
            # Fallback sur la config en cas d'erreur API
            self.bot_display_name = self.config.get("bot", {}).get("name", "KissBot")
            self.bot_login_name = self.bot_display_name.lower()
            LOGGER.error(f"âŒ Erreur API bot name, fallback config: {e}")

        # ğŸ¯ CONFIGURATION CHANNELS + EventSub WebSocket SUBSCRIPTIONS
        # ğŸ”‘ CRUCIAL : TwitchIO 3.x nÃ©cessite des subscriptions EXPLICITES !
        # Sinon : Bot connectÃ© mais "MUET" - les messages n'arrivent pas !
        
        # ğŸ”Œ SKIP EventSub si mode IRC pur
        if getattr(self, 'use_irc_mode', False):
            LOGGER.info("ğŸ”Œ Mode IRC dÃ©tectÃ© - Skip EventSub subscriptions")
            return  # Pas d'EventSub, juste IRC
        
        try:
            # RÃ©cupÃ©rer les channels de la config
            channels = self.config.get("twitch", {}).get("channels", [])
            LOGGER.info(f"ğŸ“‹ Channels configurÃ©s: {channels}")
            LOGGER.info(f"ğŸ¤– Bot ID configurÃ©: {self.bot_id}")

            # ğŸ”¥ Ã‰TAPE CRITIQUE : CrÃ©er les subscriptions EventSub pour les messages du chat
            # BasÃ© sur : TWITCHIO3_EVENTSUB_GUIDE_COMPLET.md
            for channel_name in channels:
                try:
                    # RÃ©cupÃ©rer l'ID du channel
                    users = await self.fetch_users(logins=[channel_name])
                    if not users:
                        LOGGER.warning(f"âŒ Channel {channel_name} non trouvÃ©")
                        continue

                    broadcaster = users[0]
                    broadcaster_id = broadcaster.id

                    # ğŸ”¥ DEBUG: VÃ©rifier les types
                    LOGGER.info(f"ğŸ” broadcaster_id: {broadcaster_id} (type: {type(broadcaster_id).__name__})")
                    LOGGER.info(f"ğŸ” bot_id: {self.bot_id} (type: {type(self.bot_id).__name__})")

                    # ğŸ¯ CrÃ©er la subscription ChatMessage pour EventSub WebSocket
                    # QUOI : S'abonner aux messages du channel
                    # BROADCASTER : Le channel (ex: el_serda)
                    # USER : Le bot qui reÃ§oit (ex: serda_bot, mÃªme compte si broadcaster=bot)
                    # ğŸ”‘ CRUCIAL: Utiliser le token du BROADCASTER pour les EventSub subscriptions!
                    chat_sub = eventsub.ChatMessageSubscription(
                        broadcaster_user_id=broadcaster_id,
                        user_id=self.bot_id
                    )

                    # ğŸ”¥ FIX: Convertir broadcaster_id en STRING pour matcher les clÃ©s du dictionnaire de tokens!
                    broadcaster_id_str = str(broadcaster_id)
                    LOGGER.info(f"ğŸ” token_for value: {broadcaster_id_str} (type: {type(broadcaster_id_str).__name__})")

                    # Debug: Voir quels tokens sont disponibles
                    LOGGER.info(f"ğŸ” ManagedHTTPClient tokens: {list(self._http._tokens.keys()) if hasattr(self._http, '_tokens') else 'N/A'}")
                    LOGGER.info(f"ğŸ” WebSockets avant: {list(self._websockets.keys())}")

                    # Utiliser le token du broadcaster pour la subscription
                    await self.subscribe_websocket(chat_sub, token_for=broadcaster_id_str)

                    LOGGER.info(f"ğŸ” WebSockets aprÃ¨s: {list(self._websockets.keys())}")
                    LOGGER.info(
                        f"âœ… EventSub ChatMessageSubscription crÃ©Ã©e pour: "
                        f"{broadcaster.display_name} ({broadcaster_id})"
                    )
                    print(f"âœ… EventSub Subscribe: {broadcaster.display_name} â†’ Messages incoming!")

                except Exception as e:
                    LOGGER.error(f"âŒ Erreur EventSub subscription pour {channel_name}: {e}")
                    print(f"âŒ Erreur subscription {channel_name}: {e}")
                    import traceback
                    traceback.print_exc()

            LOGGER.info("âœ… EventSub WebSocket subscriptions configurÃ©es - Bot prÃªt Ã  recevoir messages")

        except Exception as e:
            LOGGER.error(f"âŒ Erreur setup channels: {e}")

        # ğŸ”Œ DÃ©marrer IRC Bridge (asyncio pur, indÃ©pendant de TwitchIO)
        if self.irc_bridge:
            try:
                await self.irc_bridge.start()
                LOGGER.info("ğŸ”Œ IRC Bridge dÃ©marrÃ© (asyncio pur)")
            except Exception as e:
                LOGGER.warning(f"âš ï¸  Impossible de dÃ©marrer IRC Bridge: {e}")

        LOGGER.info("âœ… Setup hook terminÃ©!")
    
    def _setup_irc_fallback(self) -> None:
        """
        ğŸ”§ Monkey-patch Context.send() pour ajouter fallback IRC automatique sur 401.
        
        Si Helix Ã©choue (401 Unauthorized), rÃ©essaye avec IRC direct.
        Permet au bot de fonctionner partout sans nÃ©cessiter mod/channel:bot.
        """
        from twitchio.ext import commands as tio_commands
        from twitchio.exceptions import HTTPException
        
        # Sauvegarder la mÃ©thode originale
        original_send = tio_commands.Context.send
        
        async def send_with_irc_fallback(ctx_self, content: str, **kwargs):
            """Wrapper qui ajoute fallback IRC si 401."""
            try:
                # Tentative 1: Helix API (moderne, avec badge vÃ©rifiÃ©)
                return await original_send(ctx_self, content, **kwargs)
            except HTTPException as e:
                # Si 401 (Unauthorized) â†’ fallback IRC
                if e.status == 401:
                    LOGGER.warning(
                        f"âš ï¸  Helix 401 sur {ctx_self.channel.name} - Fallback IRC"
                    )
                    # Tentative 2: IRC direct (legacy, fonctionne partout)
                    try:
                        if hasattr(ctx_self.bot, '_connection') and ctx_self.bot._connection:
                            await ctx_self.bot._connection.send(
                                f"PRIVMSG #{ctx_self.channel.name} :{content}"
                            )
                            LOGGER.info(f"âœ… Message envoyÃ© via IRC: {ctx_self.channel.name}")
                            return None  # IRC ne retourne pas de SentMessage
                        else:
                            LOGGER.error("âŒ Pas de connexion IRC disponible")
                            raise
                    except Exception as irc_error:
                        LOGGER.error(f"âŒ Erreur IRC fallback: {irc_error}")
                        raise e  # Re-raise l'erreur Helix originale
                else:
                    # Autre erreur HTTP, on la raise normalement
                    raise
        
        # Appliquer le monkey-patch
        tio_commands.Context.send = send_with_irc_fallback
        LOGGER.info("ğŸ”§ IRC fallback activÃ© (monkey-patch Context.send)")
    
    def _broadcaster_has_channel_bot(self, broadcaster_id: str) -> bool:
        """
        VÃ©rifie si on possÃ¨de le scope channel:bot pour ce broadcaster.
        
        Args:
            broadcaster_id: ID du broadcaster (pas du bot!)
        
        Returns:
            True si on a channel:bot pour ce broadcaster
        """
        try:
            # Checker si on a les scopes pour ce user_id
            scopes = self.user_scopes.get(str(broadcaster_id), [])
            return "channel:bot" in scopes
        except Exception:
            return False
    
    async def send_chat(self, channel_name: str, message: str, broadcaster_id: str) -> bool:
        """
        ğŸ¯ Envoyer un message intelligemment: Helix si possible, sinon IRC
        
        Args:
            channel_name: Nom du channel (sans #)
            message: Message Ã  envoyer
            broadcaster_id: ID du broadcaster
            
        Returns:
            True si envoyÃ© avec succÃ¨s, False sinon
        """
        # Tentative 1: Helix API (moderne, badge vÃ©rifiÃ©)
        can_helix = self._broadcaster_has_channel_bot(str(broadcaster_id))
        if can_helix:
            try:
                users = await self.fetch_users(logins=[channel_name])
                if users:
                    await users[0].send_message(sender=self.bot_id, message=message)
                    LOGGER.info(f"âœ… Helix â†’ {channel_name}: {message}")
                    return True
            except Exception as e:
                LOGGER.warning(f"âš ï¸  Helix failed for {channel_name}: {e}, trying IRC...")
        
        # Tentative 2: IRC Bridge (universel, fonctionne partout)
        if self.irc_bridge and self.irc_bridge.is_connected():
            await self.irc_bridge.send_privmsg(channel_name, message)
            LOGGER.info(f"âœ… IRC â†’ {channel_name}: {message}")
            return True
        else:
            LOGGER.error(f"âŒ Impossible d'envoyer Ã  {channel_name}: Helix et IRC indisponibles")
            return False

    async def event_ready(self) -> None:
        """Event ready - COMME DANS LES EXEMPLES"""
        LOGGER.info("ğŸš€ Bot connectÃ©: %s", self.user)
        print(f"ğŸ‰ TwitchIO 3.x Bot Ready: {self.user}")

        # ğŸ¯ EventSub WebSocket est dÃ©jÃ  actif (configurÃ© dans setup_hook)
        # ğŸ“¡ Helix API uniquement (comme exemple officiel Twitch)
        LOGGER.info("âœ… Bot Ready - Helix API mode")

        # ğŸ¯ ENVOI MESSAGE DE COUCOU AUTOMATIQUE !
        await self.send_hello_message()

    async def send_hello_message(self) -> None:
        """Envoie un message de coucou au broadcaster"""
        try:
            # RÃ©cupÃ©rer les channels configurÃ©s
            channels = self.config.get("twitch", {}).get("channels", ["el_serda"])

            for channel_name in channels:
                print(f"ğŸ“¤ Envoi coucou vers channel: {channel_name}")

                # TwitchIO 3.x: Syntaxe correcte pour fetch_users (sans 'names')
                users = await self.fetch_users(logins=[channel_name])

                if not users:
                    print(f"âŒ User {channel_name} non trouvÃ©")
                    continue

                broadcaster = users[0]
                broadcaster_id = str(broadcaster.id)

                # Message de coucou personnalisÃ©
                message = (
                    f"ğŸ¤– Coucou {broadcaster.display_name} ! "
                    f"Comment il va {channel_name} et le chat ?! ğŸš€"
                )

                # ï¿½ï¿½ ROUTER INTELLIGEMMENT: Helix â†’ IRC automatique
                print(f"ğŸ“¤ Envoi vers {channel_name} (ID: {broadcaster_id})...")
                success = await self.send_chat(channel_name, message, broadcaster_id)
                
                if success:
                    print(f"âœ… MESSAGE ENVOYÃ‰ Ã  {channel_name} !")
                else:
                    print(f"âŒ Ã‰chec envoi Ã  {channel_name}")

        except Exception as e:
            LOGGER.error("âŒ Erreur globale envoi coucou: %s", e)

    async def event_oauth_authorized(
        self, payload: twitchio.authentication.UserTokenPayload
    ) -> None:
        """OAuth authorized - COMME DANS LES EXEMPLES"""
        LOGGER.info("ğŸ”‘ OAuth authorized pour user: %s", payload.user_id)

        # Stocker le token
        await self.add_token(payload.access_token, payload.refresh_token)

        if payload.user_id == self.bot_id:
            LOGGER.info("ğŸ¤– Bot token rÃ©cupÃ©rÃ©")
            return

        # Subscribe au chat pour ce user
        # ğŸ¯ FULL EventSub WebSocket SOLUTION:
        # Si c'est le bot lui-mÃªme (broadcaster = bot), alors autorisation OK !
        chat_sub = eventsub.ChatMessageSubscription(
            broadcaster_user_id=payload.user_id,  # Le bot Ã©coute son propre channel
            user_id=self.bot_id  # Avec son propre bot_id
        )

        try:
            await self.subscribe_websocket(chat_sub)
            LOGGER.info("âœ… EventSub Chat Subscription crÃ©Ã©e pour %s", payload.user_id)
        except Exception as e:
            LOGGER.error("âŒ Erreur EventSub subscription: %s", e)

    async def event_message(self, payload: twitchio.ChatMessage) -> None:
        """Event message - FIXED selon TWITCHIO3_EVENTSUB_GUIDE_COMPLET

        ğŸ¯ BasÃ© sur la doc : traiter les messages correctement mÃªme avec same account (bot=broadcaster)
        """
        # Log le message
        LOGGER.info("[%s]: %s", payload.chatter.name, payload.text)
        print(f"ğŸ’¬ {payload.chatter.name}: {payload.text}")

        # ğŸ” DEBUG : VÃ©rifier l'Ã©tat du message
        print(f"ğŸ” DEBUG: chatter.id={payload.chatter.id}, bot_id={self.bot_id}")
        is_same_account = payload.chatter.id == self.bot_id
        print(f"ğŸ” Same account (bot=broadcaster): {is_same_account}")

        # ğŸ¯ FIX CRUCIAL (de la doc) :
        # TwitchIO 3.x ignore les messages du bot par dÃ©faut
        # MAIS nous on VEUT traiter nos propres commandes si bot=broadcaster !

        # âœ… SOLUTION : Appel direct de process_commands
        # (Pas super().event_message() qui bloque same account)
        print("ï¿½ Appel process_commands() directement")
        await self.process_commands(payload)
        print("âœ… process_commands() terminÃ©")

        # ğŸ§  MENTIONS : VÃ©rifier si le bot est mentionnÃ©
        # Seulement si ce n'est PAS un message du bot lui-mÃªme !
        if is_same_account:
            # Le bot ne doit pas rÃ©pondre Ã  ses propres mentions
            print("ğŸš« Message du bot lui-mÃªme - pas de mention handling")
            return

        # TwitchIO 3.x : utiliser le nom rÃ©cupÃ©rÃ© via API
        bot_name = getattr(self, 'bot_login_name', self.config.get("bot", {}).get("name", "serda_bot")).lower()

        if (f"@{bot_name}" in payload.text.lower() or
                bot_name in payload.text.lower()):
            print("ğŸ§  DEBUG: Mention dÃ©tectÃ©e !")
            try:
                from commands.intelligence_commands import handle_mention_v3
                response = await handle_mention_v3(self, payload)
                if response:
                    # Envoyer la rÃ©ponse dans le canal - TwitchIO 3.x
                    # payload a un broadcaster, utilisons Ã§a
                    if hasattr(payload, 'broadcaster'):
                        await payload.broadcaster.send_message(
                            sender=self.bot_id,
                            message=response
                        )
                        print(f"ğŸ§  RÃ©ponse mention envoyÃ©e: {response}")
                    else:
                        print("âŒ Pas de broadcaster disponible pour rÃ©ponse")
                else:
                    print("ğŸ§  Pas de rÃ©ponse mention (rate limit ou erreur)")
            except Exception as e:
                print(f"âŒ Erreur mention response: {e}")


class TestCommands(commands.Component):
    """Component de test - BASÃ‰ SUR LES EXEMPLES OFFICIELS"""

    @commands.command(aliases=["hello", "salut"])
    async def hi(self, ctx) -> None:
        """Commande Hi simple - COMME DANS LES EXEMPLES

        !hi, !hello, !salut
        """
        try:
            # Utilisation de ctx.reply comme dans les exemples
            result = await ctx.reply(f"ğŸ§ª TwitchIO 3.x fonctionne! Salut {ctx.chatter.mention}!")

            # TwitchIO 3.x: On a un VRAI rÃ©sultat !
            print(f"âœ… Message envoyÃ© avec succÃ¨s: {result}")
            LOGGER.info("âœ… Hi command result: %s", result)

        except Exception as e:
            print(f"âŒ Erreur commande hi: {e}")
            LOGGER.error("âŒ Hi command error: %s", e)

    @commands.command()
    async def test3(self, ctx) -> None:
        """Test TwitchIO 3.x feedback

        !test3
        """
        try:
            # Test avec ctx.send
            result = await ctx.send("ğŸ”¬ Test TwitchIO 3.x - Feedback disponible!")

            print(f"ğŸ§ª Test3 result: {result}")
            print(f"ğŸ§ª Type: {type(result)}")

            # TwitchIO 3.x donne de vraies infos !
            if hasattr(result, 'id'):
                print(f"ğŸ“‹ Message ID: {result.id}")

        except Exception as e:
            print(f"âŒ Erreur test3: {e}")

    @commands.command()
    async def say(self, ctx, *, message: str) -> None:
        """RÃ©pÃ¨te un message - COMME DANS LES EXEMPLES

        !say votre message ici
        """
        # TwitchIO 3.x: VÃ©rifier si l'utilisateur est modÃ©rateur ou broadcaster
        is_mod = any(badge.name == "moderator" for badge in ctx.chatter.badges) if ctx.chatter.badges else False
        is_broadcaster = ctx.chatter.id == ctx.broadcaster.id if ctx.broadcaster else False

        if not is_mod and not is_broadcaster:
            await ctx.reply("âŒ Commande rÃ©servÃ©e aux mods!")
            return

        try:
            result = await ctx.send(message)
            print(f"ğŸ”Š Say result: {result}")
        except Exception as e:
            await ctx.reply(f"âŒ Erreur: {e}")


async def main():
    """Point d'entrÃ©e principal - COMME DANS LES EXEMPLES"""

    # Setup logging comme dans les exemples officiels
    twitchio.utils.setup_logging(level=logging.INFO)

    print("ğŸš€ KissBot V3 WORKING - TwitchIO 3.x Official Examples")
    print("=" * 60)

    async def runner() -> None:
        # Utilisation du context manager comme dans les exemples
        async with KissBotV3Working() as bot:
            print("ğŸ¯ Bot crÃ©Ã©, dÃ©marrage...")

            # Pour tester, on peut crÃ©er des tokens manuellement
            # Ou utiliser le flow OAuth comme dans les exemples

            await bot.start()

    try:
        await runner()
    except KeyboardInterrupt:
        LOGGER.warning("ğŸ›‘ ArrÃªt du bot (Keyboard Interrupt)")
        print("ğŸ›‘ Bot arrÃªtÃ© manuellement")
    except Exception as e:
        LOGGER.error("âŒ Erreur bot: %s", e)
        print(f"âŒ Erreur: {e}")


if __name__ == "__main__":
    # Comme dans TOUS les exemples officiels
    asyncio.run(main())
