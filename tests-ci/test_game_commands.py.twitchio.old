"""
Tests for commands/game_commands.py - Phase 4: Commands Integration with async + twitchio mocks.

Test Strategy:
- Mock twitchio Context, Channel, Bot
- Mock Twitch API calls (fetch_users, fetch_streams)
- Mock GameLookup class and methods
- Test !gameinfo (!gi) command with various inputs
- Test !gamecategory (!gc) command with live/offline streams
- Test error handling (API down, missing config, invalid inputs)
- Test message formatting and edge cases

Coverage Target: 17% ‚Üí 80%+ on commands/game_commands.py
"""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from commands.game_commands import GameCommands
from backends.game_lookup import GameResult


# ============================================================================
# Test Class 1: !gameinfo (!gi) Command - Success Cases
# ============================================================================
class TestGameinfoCommandSuccess:
    """Test !gameinfo command with valid inputs."""

    @pytest.mark.asyncio
    async def test_gameinfo_valid_game_name(self):
        """Test !gi with valid game name returns game info."""
        # Setup
        game_commands = GameCommands()
        
        # Mock context
        ctx = MagicMock()
        ctx.send = AsyncMock()
        
        # Mock bot with config
        mock_bot = MagicMock()
        mock_bot.config = {"apis": {"rawg_key": "test_key"}}
        ctx.bot = mock_bot
        
        # Mock GameLookup
        mock_result = GameResult(
            name="Brotato",
            year="2023",
            rating_rawg=4.5,
            metacritic=85,
            confidence="HIGH",
            source_count=2
        )
        
        with patch('commands.game_commands.GameLookup') as MockLookup:
            mock_lookup = MockLookup.return_value
            mock_lookup.search_game = AsyncMock(return_value=mock_result)
            mock_lookup.format_result = MagicMock(return_value="üéÆ Brotato (2023) - üèÜ 85/100 - üî• HIGH")
            
            # Execute
            await game_commands.game_command.callback(game_commands, ctx, game_name="Brotato")
            
            # Assert
            ctx.send.assert_called_once()
            sent_message = ctx.send.call_args[0][0]
            assert "üéÆ Brotato" in sent_message
            assert "2023" in sent_message
            mock_lookup.search_game.assert_called_once_with("Brotato")

    @pytest.mark.asyncio
    async def test_gameinfo_with_typo_fuzzy_match(self):
        """Test !gi with typo successfully finds game via fuzzy matching."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.bot = MagicMock()
        ctx.bot.config = {"apis": {"rawg_key": "test_key"}}
        
        # Mock fuzzy match result (typo "stardw" ‚Üí "Stardew Valley")
        mock_result = GameResult(
            name="Stardew Valley",
            year="2016",
            rating_rawg=4.8,
            confidence="HIGH",
            source_count=2,
            possible_typo=True
        )
        
        with patch('commands.game_commands.GameLookup') as MockLookup:
            mock_lookup = MockLookup.return_value
            mock_lookup.search_game = AsyncMock(return_value=mock_result)
            mock_lookup.format_result = MagicMock(return_value="üéÆ Stardew Valley (2016)")
            
            await game_commands.game_command.callback(game_commands, ctx, game_name="stardw valey")
            
            ctx.send.assert_called_once()
            sent_message = ctx.send.call_args[0][0]
            assert "Stardew Valley" in sent_message

    @pytest.mark.asyncio
    async def test_gameinfo_multi_word_game_name(self):
        """Test !gi with multi-word game name."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.bot = MagicMock()
        ctx.bot.config = {"apis": {"rawg_key": "test_key"}}
        
        mock_result = GameResult(
            name="The Binding of Isaac: Rebirth",
            year="2014",
            rating_rawg=4.6,
            confidence="HIGH",
            source_count=2
        )
        
        with patch('commands.game_commands.GameLookup') as MockLookup:
            mock_lookup = MockLookup.return_value
            mock_lookup.search_game = AsyncMock(return_value=mock_result)
            mock_lookup.format_result = MagicMock(return_value="üéÆ The Binding of Isaac: Rebirth")
            
            await game_commands.game_command.callback(game_commands, ctx, game_name="The Binding of Isaac Rebirth")
            
            ctx.send.assert_called_once()
            mock_lookup.search_game.assert_called_once_with("The Binding of Isaac Rebirth")


# ============================================================================
# Test Class 2: !gameinfo (!gi) Command - Error Cases
# ============================================================================
class TestGameinfoCommandErrors:
    """Test !gi command error handling."""

    @pytest.mark.asyncio
    async def test_gameinfo_no_game_name_shows_usage(self):
        """Test !gi without game name shows usage message."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        
        # Execute with no game name
        await game_commands.game_command.callback(game_commands, ctx, game_name=None)
        
        # Assert usage message
        ctx.send.assert_called_once()
        sent_message = ctx.send.call_args[0][0]
        assert "Usage" in sent_message or "üéÆ" in sent_message

    @pytest.mark.asyncio
    async def test_gameinfo_empty_string_shows_usage(self):
        """Test !gi with empty string shows usage message."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        
        await game_commands.game_command.callback(game_commands, ctx, game_name="")
        
        ctx.send.assert_called_once()
        sent_message = ctx.send.call_args[0][0]
        assert "Usage" in sent_message

    @pytest.mark.asyncio
    async def test_gameinfo_game_not_found(self):
        """Test !gi with non-existent game shows not found message."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.bot = MagicMock()
        ctx.bot.config = {"apis": {"rawg_key": "test_key"}}
        
        with patch('commands.game_commands.GameLookup') as MockLookup:
            mock_lookup = MockLookup.return_value
            mock_lookup.search_game = AsyncMock(return_value=None)
            
            await game_commands.game_command.callback(game_commands, ctx, game_name="NonExistentGame12345XYZ")
            
            ctx.send.assert_called_once()
            sent_message = ctx.send.call_args[0][0]
            assert "non trouv√©" in sent_message or "‚ùå" in sent_message

    @pytest.mark.asyncio
    async def test_gameinfo_missing_bot_config(self):
        """Test !gi when bot has no config attribute."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.bot = MagicMock(spec=[])  # Bot without config attribute
        
        await game_commands.game_command.callback(game_commands, ctx, game_name="Brotato")
        
        ctx.send.assert_called_once()
        sent_message = ctx.send.call_args[0][0]
        assert "non disponible" in sent_message or "‚ùå" in sent_message

    @pytest.mark.asyncio
    async def test_gameinfo_api_exception(self):
        """Test !gi when API raises exception."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.bot = MagicMock()
        ctx.bot.config = {"apis": {"rawg_key": "test_key"}}
        
        with patch('commands.game_commands.GameLookup') as MockLookup:
            mock_lookup = MockLookup.return_value
            mock_lookup.search_game = AsyncMock(side_effect=Exception("API Error"))
            
            await game_commands.game_command.callback(game_commands, ctx, game_name="TestGame")
            
            ctx.send.assert_called_once()
            sent_message = ctx.send.call_args[0][0]
            assert "Erreur" in sent_message or "‚ùå" in sent_message


# ============================================================================
# Test Class 3: !gamecategory (!gc) Command - Live Stream Cases
# ============================================================================
class TestGamecategoryCommandLiveStream:
    """Test !gc command with live streams."""

    @pytest.mark.asyncio
    async def test_gamecategory_live_stream_with_game(self):
        """Test !gc when stream is live with a game category."""
        game_commands = GameCommands()
        
        # Mock context with channel
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.channel = MagicMock()
        ctx.channel.name = "test_streamer"
        
        # Mock bot
        mock_bot = MagicMock()
        mock_bot.config = {"apis": {"rawg_key": "test_key"}}
        ctx.bot = mock_bot
        
        # Mock Twitch API responses
        mock_user = MagicMock()
        mock_user.id = "123456"
        mock_bot.fetch_users = AsyncMock(return_value=[mock_user])
        
        mock_stream = MagicMock()
        mock_stream.game_name = "Brotato"
        mock_bot.fetch_streams = AsyncMock(return_value=[mock_stream])
        
        # Mock GameLookup
        mock_result = GameResult(
            name="Brotato",
            year="2023",
            rating_rawg=4.5,
            confidence="IGDB_VERIFIED",
            source_count=2
        )
        
        with patch('commands.game_commands.GameLookup') as MockLookup:
            mock_lookup = MockLookup.return_value
            mock_lookup.enrich_game_from_igdb_name = AsyncMock(return_value=mock_result)
            mock_lookup.format_result = MagicMock(return_value="üéÆ Brotato (2023)")
            
            await game_commands.game_category_command.callback(game_commands, ctx)
            
            # Assert API calls (pytwitchAPI uses 'logins' not 'names')
            mock_bot.fetch_users.assert_called_once_with(logins=["test_streamer"])
            mock_bot.fetch_streams.assert_called_once_with(user_ids=["123456"])
            mock_lookup.enrich_game_from_igdb_name.assert_called_once_with("Brotato")
            
            # Assert message sent
            ctx.send.assert_called_once()
            sent_message = ctx.send.call_args[0][0]
            assert "Brotato" in sent_message

    @pytest.mark.asyncio
    async def test_gamecategory_live_stream_game_enrichment_fails(self):
        """Test !gc when IGDB enrichment returns None but stream has game."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.channel = MagicMock()
        ctx.channel.name = "test_streamer"
        
        mock_bot = MagicMock()
        mock_bot.config = {"apis": {"rawg_key": "test_key"}}
        ctx.bot = mock_bot
        
        mock_user = MagicMock()
        mock_user.id = "123456"
        mock_bot.fetch_users = AsyncMock(return_value=[mock_user])
        
        mock_stream = MagicMock()
        mock_stream.game_name = "Obscure Game"
        mock_bot.fetch_streams = AsyncMock(return_value=[mock_stream])
        
        with patch('commands.game_commands.GameLookup') as MockLookup:
            mock_lookup = MockLookup.return_value
            mock_lookup.enrich_game_from_igdb_name = AsyncMock(return_value=None)
            
            await game_commands.game_category_command.callback(game_commands, ctx)
            
            ctx.send.assert_called_once()
            sent_message = ctx.send.call_args[0][0]
            assert "non trouv√©" in sent_message or "‚ùå" in sent_message
            assert "Obscure Game" in sent_message


# ============================================================================
# Test Class 4: !gamecategory (!gc) Command - Offline/No Game Cases
# ============================================================================
class TestGamecategoryCommandOffline:
    """Test !gc command when stream is offline or has no game."""

    @pytest.mark.asyncio
    async def test_gamecategory_stream_offline(self):
        """Test !gc when stream is offline (no streams returned)."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.channel = MagicMock()
        ctx.channel.name = "offline_streamer"
        
        mock_bot = MagicMock()
        mock_bot.config = {"apis": {"rawg_key": "test_key"}}
        ctx.bot = mock_bot
        
        mock_user = MagicMock()
        mock_user.id = "123456"
        mock_bot.fetch_users = AsyncMock(return_value=[mock_user])
        mock_bot.fetch_streams = AsyncMock(return_value=[])  # No streams = offline
        
        await game_commands.game_category_command.callback(game_commands, ctx)
        
        ctx.send.assert_called_once()
        sent_message = ctx.send.call_args[0][0]
        assert "n'est pas sur un jeu" in sent_message or "Nullos" in sent_message

    @pytest.mark.asyncio
    async def test_gamecategory_stream_no_game_category(self):
        """Test !gc when stream is live but has no game category."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.channel = MagicMock()
        ctx.channel.name = "chatting_streamer"
        
        mock_bot = MagicMock()
        mock_bot.config = {"apis": {"rawg_key": "test_key"}}
        ctx.bot = mock_bot
        
        mock_user = MagicMock()
        mock_user.id = "123456"
        mock_bot.fetch_users = AsyncMock(return_value=[mock_user])
        
        mock_stream = MagicMock()
        mock_stream.game_name = None  # No game (Just Chatting)
        mock_bot.fetch_streams = AsyncMock(return_value=[mock_stream])
        
        await game_commands.game_category_command.callback(game_commands, ctx)
        
        ctx.send.assert_called_once()
        sent_message = ctx.send.call_args[0][0]
        assert "n'est pas sur un jeu" in sent_message or "Nullos" in sent_message

    @pytest.mark.asyncio
    async def test_gamecategory_stream_empty_game_name(self):
        """Test !gc when stream has empty game name string."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.channel = MagicMock()
        ctx.channel.name = "test_streamer"
        
        mock_bot = MagicMock()
        mock_bot.config = {"apis": {"rawg_key": "test_key"}}
        ctx.bot = mock_bot
        
        mock_user = MagicMock()
        mock_user.id = "123456"
        mock_bot.fetch_users = AsyncMock(return_value=[mock_user])
        
        mock_stream = MagicMock()
        mock_stream.game_name = ""  # Empty string
        mock_bot.fetch_streams = AsyncMock(return_value=[mock_stream])
        
        await game_commands.game_category_command.callback(game_commands, ctx)
        
        ctx.send.assert_called_once()
        sent_message = ctx.send.call_args[0][0]
        assert "n'est pas sur un jeu" in sent_message


# ============================================================================
# Test Class 5: !gamecategory (!gc) Command - Error Cases
# ============================================================================
class TestGamecategoryCommandErrors:
    """Test !gc command error handling."""

    @pytest.mark.asyncio
    async def test_gamecategory_no_channel(self):
        """Test !gc when context has no channel."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.channel = None  # No channel
        
        await game_commands.game_category_command.callback(game_commands, ctx)
        
        ctx.send.assert_called_once()
        sent_message = ctx.send.call_args[0][0]
        assert "Impossible de d√©terminer le channel" in sent_message or "‚ùå" in sent_message

    @pytest.mark.asyncio
    async def test_gamecategory_user_not_found(self):
        """Test !gc when Twitch user not found."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.channel = MagicMock()
        ctx.channel.name = "nonexistent_user"
        
        mock_bot = MagicMock()
        mock_bot.config = {"apis": {"rawg_key": "test_key"}}
        ctx.bot = mock_bot
        
        mock_bot.fetch_users = AsyncMock(return_value=[])  # User not found
        
        await game_commands.game_category_command.callback(game_commands, ctx)
        
        ctx.send.assert_called_once()
        sent_message = ctx.send.call_args[0][0]
        assert "non trouv√©" in sent_message or "‚ùå" in sent_message

    @pytest.mark.asyncio
    async def test_gamecategory_missing_bot_config(self):
        """Test !gc when bot has no config."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.channel = MagicMock()
        ctx.channel.name = "test_streamer"
        
        mock_bot = MagicMock(spec=["fetch_users", "fetch_streams"])  # No config
        ctx.bot = mock_bot
        
        mock_user = MagicMock()
        mock_user.id = "123456"
        mock_bot.fetch_users = AsyncMock(return_value=[mock_user])
        
        mock_stream = MagicMock()
        mock_stream.game_name = "Brotato"
        mock_bot.fetch_streams = AsyncMock(return_value=[mock_stream])
        
        await game_commands.game_category_command.callback(game_commands, ctx)
        
        ctx.send.assert_called_once()
        sent_message = ctx.send.call_args[0][0]
        assert "non disponible" in sent_message or "‚ùå" in sent_message

    @pytest.mark.asyncio
    async def test_gamecategory_twitch_api_exception(self):
        """Test !gc when Twitch API raises exception."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.channel = MagicMock()
        ctx.channel.name = "test_streamer"
        
        mock_bot = MagicMock()
        mock_bot.config = {"apis": {"rawg_key": "test_key"}}
        ctx.bot = mock_bot
        
        # Twitch API raises exception
        mock_bot.fetch_users = AsyncMock(side_effect=Exception("Twitch API Error"))
        
        await game_commands.game_category_command.callback(game_commands, ctx)
        
        ctx.send.assert_called_once()
        sent_message = ctx.send.call_args[0][0]
        assert "Erreur" in sent_message or "‚ùå" in sent_message


# ============================================================================
# Test Class 6: Message Formatting and Edge Cases
# ============================================================================
class TestMessageFormattingAndEdgeCases:
    """Test message formatting, length limits, and edge cases."""

    @pytest.mark.asyncio
    async def test_gameinfo_message_contains_emoji(self):
        """Test !gi message contains proper emoji formatting."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.bot = MagicMock()
        ctx.bot.config = {"apis": {"rawg_key": "test_key"}}
        
        mock_result = GameResult(
            name="Hades",
            year="2020",
            rating_rawg=4.8,
            metacritic=93,
            confidence="HIGH",
            source_count=2
        )
        
        with patch('commands.game_commands.GameLookup') as MockLookup:
            mock_lookup = MockLookup.return_value
            mock_lookup.search_game = AsyncMock(return_value=mock_result)
            mock_lookup.format_result = MagicMock(return_value="üéÆ Hades (2020) - üèÜ 93/100 - üî• HIGH")
            
            await game_commands.game_command.callback(game_commands, ctx, game_name="Hades")
            
            sent_message = ctx.send.call_args[0][0]
            assert "üéÆ" in sent_message
            assert any(emoji in sent_message for emoji in ["üèÜ", "üî•", "‚≠ê"])

    @pytest.mark.asyncio
    async def test_gamecategory_message_includes_broadcaster_name(self):
        """Test !gc message includes broadcaster @mention."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.channel = MagicMock()
        ctx.channel.name = "coolstreamer"
        
        mock_bot = MagicMock()
        mock_bot.config = {"apis": {"rawg_key": "test_key"}}
        ctx.bot = mock_bot
        
        mock_user = MagicMock()
        mock_user.id = "123456"
        mock_bot.fetch_users = AsyncMock(return_value=[mock_user])
        mock_bot.fetch_streams = AsyncMock(return_value=[])  # Offline
        
        await game_commands.game_category_command.callback(game_commands, ctx)
        
        sent_message = ctx.send.call_args[0][0]
        # Message should contain broadcaster name
        assert "coolstreamer" in sent_message or "@coolstreamer" in sent_message

    @pytest.mark.asyncio
    async def test_gameinfo_special_characters_in_game_name(self):
        """Test !gi handles game names with special characters."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.bot = MagicMock()
        ctx.bot.config = {"apis": {"rawg_key": "test_key"}}
        
        mock_result = GameResult(
            name="Don't Starve",
            year="2013",
            rating_rawg=4.2,
            confidence="HIGH",
            source_count=2
        )
        
        with patch('commands.game_commands.GameLookup') as MockLookup:
            mock_lookup = MockLookup.return_value
            mock_lookup.search_game = AsyncMock(return_value=mock_result)
            mock_lookup.format_result = MagicMock(return_value="üéÆ Don't Starve (2013)")
            
            await game_commands.game_command.callback(game_commands, ctx, game_name="Don't Starve")
            
            ctx.send.assert_called_once()
            mock_lookup.search_game.assert_called_once_with("Don't Starve")

    @pytest.mark.asyncio
    async def test_gameinfo_unicode_characters(self):
        """Test !gi handles unicode characters in game name."""
        game_commands = GameCommands()
        
        ctx = MagicMock()
        ctx.send = AsyncMock()
        ctx.bot = MagicMock()
        ctx.bot.config = {"apis": {"rawg_key": "test_key"}}
        
        mock_result = GameResult(
            name="„É¢„É≥„Çπ„Çø„Éº„Éè„É≥„Çø„Éº",
            year="2021",
            rating_rawg=4.5,
            confidence="MEDIUM",
            source_count=1
        )
        
        with patch('commands.game_commands.GameLookup') as MockLookup:
            mock_lookup = MockLookup.return_value
            mock_lookup.search_game = AsyncMock(return_value=mock_result)
            mock_lookup.format_result = MagicMock(return_value="üéÆ „É¢„É≥„Çπ„Çø„Éº„Éè„É≥„Çø„Éº (2021)")
            
            await game_commands.game_command.callback(game_commands, ctx, game_name="„É¢„É≥„Çπ„Çø„Éº„Éè„É≥„Çø„Éº")
            
            ctx.send.assert_called_once()
            sent_message = ctx.send.call_args[0][0]
            assert "„É¢„É≥„Çπ„Çø„Éº„Éè„É≥„Çø„Éº" in sent_message


# ============================================================================
# Test Class 7: Component Initialization
# ============================================================================
class TestComponentInitialization:
    """Test GameCommands component initialization."""

    def test_component_initialization(self):
        """Test GameCommands initializes as TwitchIO 3.x Component."""
        game_commands = GameCommands()
        
        # Should initialize without errors
        assert game_commands is not None
        
        # Should have command methods
        assert hasattr(game_commands, 'game_command')
        assert hasattr(game_commands, 'game_category_command')
        
        # Commands should be async
        assert callable(game_commands.game_command)
        assert callable(game_commands.game_category_command)
